// <auto-generated />
//
// To parse this JSON data, add NuGet 'System.Text.Json' then do:
//
//    using Common.Models;
//
//    var workflow = Workflow.FromJson(jsonString);

#pragma warning disable CS8618
#pragma warning disable CS8601
#pragma warning disable CS8603

namespace FlowActivationOrder.Models
{
    using System;
    using System.Collections.Generic;

    using System.Text.Json;
    using System.Text.Json.Serialization;
    using System.Globalization;
    using FlowActivationOrder.Utils;

    /// <summary>
    /// The workflow.
    /// </summary>
    public partial class WorkflowDefinition
    {
        /// <summary>
        /// The definition schema.
        /// </summary>
        [JsonPropertyName("$schema")]
        public WorkflowDefinitionSchema Schema { get; set; }

        /// <summary>
        /// The flow run actions.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }

        /// <summary>
        /// The flow content version. Specify using a 4-digit format, e.g., 1.0.0.0
        /// </summary>
        [JsonPropertyName("contentVersion")]
        public string ContentVersion { get; set; }

        /// <summary>
        /// The definition description.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The definition metadata.
        /// </summary>
        [JsonPropertyName("metadata")]
        public object Metadata { get; set; }

        /// <summary>
        /// The flow outputs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("outputs")]
        public Dictionary<string, OutputValue> Outputs { get; set; }

        /// <summary>
        /// The flow parameters.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("parameters")]
        public Dictionary<string, ParameterValue> Parameters { get; set; }

        /// <summary>
        /// The flow triggers.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("triggers")]
        public Dictionary<string, Trigger> Triggers { get; set; }
    }

    /// <summary>
    /// A flow template action.
    /// </summary>
    public partial class Action
    {
        /// <summary>
        /// The operation run after.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("runAfter")]
        public Dictionary<string, FlowStatus[]> RunAfter { get; set; }

        /// <summary>
        /// The tracked properties.
        /// </summary>
        [JsonPropertyName("trackedProperties")]
        public object TrackedProperties { get; set; }

        /// <summary>
        /// The operation description.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The kind of the flow operation.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("kind")]
        public ActionKind? Kind { get; set; }

        /// <summary>
        /// The operation metadata.
        /// </summary>
        [JsonPropertyName("metadata")]
        public object Metadata { get; set; }

        /// <summary>
        /// The operation options.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("operationOptions")]
        public string OperationOptions { get; set; }

        /// <summary>
        /// The flow template operation runtime configuration.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("runtimeConfiguration")]
        public ActionRuntimeConfiguration RuntimeConfiguration { get; set; }

        /// <summary>
        /// The type of the flow operation.
        /// </summary>
        [JsonPropertyName("type")]
        public ActionType Type { get; set; }

        /// <summary>
        /// The ApiConnection operation input.
        ///
        /// The API connection webhook operation input.
        ///
        /// The API Management operation input.
        ///
        /// The Send to Batch action input.
        ///
        /// The Compose action input.
        ///
        /// The inputs for the add to time or subtract from time operation kinds.
        ///
        /// The convert time zone operation kind input.
        ///
        /// The inputs for the get future time and get past time operation kinds.
        ///
        /// The content and schema action input.
        ///
        /// The flat file encoding action input.
        ///
        /// The function action input.
        ///
        /// The integration account artifact lookup input.
        ///
        /// The Join action input.
        ///
        /// The liquid action input.
        ///
        /// The Parse JSON action input.
        ///
        /// The query action input.
        ///
        /// The response action input.
        ///
        /// The Select action input.
        ///
        /// The table action input.
        ///
        /// The Terminate action input.
        ///
        /// The variable action input.
        ///
        /// The Initialize Variable action input.
        ///
        /// The Wait action input.
        ///
        /// The flow action input.
        ///
        /// The XSLT (Extensible Stylesheet Language Transformations) action input.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("inputs")]
        public InputsUnion? Inputs { get; set; }


        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }

        /// <summary>
        /// The For Each expression.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("foreach")]
        public From? Foreach { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("else")]
        public IfElseProperty Else { get; set; }

        /// <summary>
        /// The If expression.
        ///
        /// The Switch expression.
        ///
        /// The Until expression.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("expression")]
        public Expression? Expression { get; set; }

        /// <summary>
        /// The Switch action case branches.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cases")]
        public Dictionary<string, FlowTemplateActionCaseBranch> Cases { get; set; }

        /// <summary>
        /// The flow template action branch.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("default")]
        public Default Default { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("limit")]
        public UntilLimitProperty Limit { get; set; }
    }

    /// <summary>
    /// The flow template action case branch.
    /// </summary>
    public partial class FlowTemplateActionCaseBranch
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }

        /// <summary>
        /// The case.
        /// </summary>
        [JsonPropertyName("case")]
        public object Case { get; set; }
    }

    /// <summary>
    /// The flow template action branch.
    /// </summary>
    public partial class Default
    {
        /// <summary>
        /// The actions.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }
    }

    public partial class IfElseProperty
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }
    }

    /// <summary>
    /// The Until limits.
    /// </summary>
    public partial class UntilLimitProperty
    {
        /// <summary>
        /// The until count limit.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("count")]
        public Expression? Count { get; set; }

        /// <summary>
        /// The until timeout limit.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timeout")]
        public string Timeout { get; set; }
    }

    /// <summary>
    /// The flow template operation runtime configuration.
    /// </summary>
    public partial class ActionRuntimeConfiguration
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("concurrency")]
        public FlowConcurrencyConfiguration Concurrency { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("contentTransfer")]
        public FlowContentTransferConfiguration ContentTransfer { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("paginationPolicy")]
        public FlowPaginationPolicy PaginationPolicy { get; set; }
    }

    /// <summary>
    /// The flow concurrency configuration.
    /// </summary>
    public partial class FlowConcurrencyConfiguration
    {
        /// <summary>
        /// The maximum waiting runs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maximumWaitingRuns")]
        public long? MaximumWaitingRuns { get; set; }

        /// <summary>
        /// The repetitions.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("repetitions")]
        public long? Repetitions { get; set; }

        /// <summary>
        /// The runs.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("runs")]
        public long? Runs { get; set; }
    }

    /// <summary>
    /// The flow content transfer configuration.
    /// </summary>
    public partial class FlowContentTransferConfiguration
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("transferMode")]
        public FlowContentTransferMode? TransferMode { get; set; }
    }

    /// <summary>
    /// The flow pagination policy.
    /// </summary>
    public partial class FlowPaginationPolicy
    {
        /// <summary>
        /// The minimum item count.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minimumItemCount")]
        public long? MinimumItemCount { get; set; }
    }

    /// <summary>
    /// The flow output template parameter.
    ///
    /// The flow template parameter.
    /// </summary>
    public partial class OutputValue
    {
        /// <summary>
        /// The parameter description.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The parameter metadata.
        /// </summary>
        [JsonPropertyName("metadata")]
        public object Metadata { get; set; }

        /// <summary>
        /// The parameter type.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public OutputType? Type { get; set; }

        /// <summary>
        /// The parameter value.
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }

        /// <summary>
        /// The error of the output parameter.
        /// </summary>
        [JsonPropertyName("error")]
        public object Error { get; set; }
    }

    /// <summary>
    /// The flow template parameter.
    /// </summary>
    public partial class ParameterValue
    {
        /// <summary>
        /// The parameter description.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The parameter metadata.
        /// </summary>
        [JsonPropertyName("metadata")]
        public object Metadata { get; set; }

        /// <summary>
        /// The parameter type.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public OutputType? Type { get; set; }

        /// <summary>
        /// The parameter value.
        /// </summary>
        [JsonPropertyName("value")]
        public object Value { get; set; }

        /// <summary>
        /// The allowed parameter values.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("allowedValues")]
        public object[] AllowedValues { get; set; }

        /// <summary>
        /// The default parameter value.
        /// </summary>
        [JsonPropertyName("defaultValue")]
        public object DefaultValue { get; set; }
    }

    /// <summary>
    /// A flow template trigger.
    /// </summary>
    public partial class Trigger
    {
        /// <summary>
        /// The operation description.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// The kind of the flow operation.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("kind")]
        public TriggerKind? Kind { get; set; }

        /// <summary>
        /// The operation metadata.
        /// </summary>
        [JsonPropertyName("metadata")]
        public object Metadata { get; set; }

        /// <summary>
        /// The operation options.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("operationOptions")]
        public string OperationOptions { get; set; }

        /// <summary>
        /// The flow template operation runtime configuration.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("runtimeConfiguration")]
        public TriggerRuntimeConfiguration RuntimeConfiguration { get; set; }

        /// <summary>
        /// The type of the flow operation.
        /// </summary>
        [JsonPropertyName("type")]
        public TriggerType Type { get; set; }

        /// <summary>
        /// The operation conditions.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("conditions")]
        public Workflo[] Conditions { get; set; }

        /// <summary>
        /// The correlation properties.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("correlation")]
        public TriggerCorrelation Correlation { get; set; }

        /// <summary>
        /// The trigger split on.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("splitOn")]
        public string SplitOn { get; set; }

        /// <summary>
        /// The trigger SplitOn configuration.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("splitOnConfiguration")]
        public SplitOnConfiguration SplitOnConfiguration { get; set; }

        /// <summary>
        /// The API connection webhook operation input.
        ///
        /// The HTTP action input.
        ///
        /// The manual action input.
        ///
        /// The sliding window action input.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("inputs")]
        public InputsUnion? Inputs { get; set; }

        /// <summary>
        /// The flow recurrence.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("recurrence")]
        public TriggerRecurrence Recurrence { get; set; }
    }

    /// <summary>
    /// The template action expression condition.
    /// </summary>
    public partial class Workflo
    {
        /// <summary>
        /// The dependency.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("dependsOn")]
        public string DependsOn { get; set; }

        /// <summary>
        /// The expression.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("expression")]
        public string Expression { get; set; }
    }

    /// <summary>
    /// The correlation properties.
    /// </summary>
    public partial class TriggerCorrelation
    {
        /// <summary>
        /// The client tracking identifier.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("clientTrackingId")]
        public string ClientTrackingId { get; set; }
    }

    /// <summary>
    /// The ApiConnection operation input.
    ///
    /// The retryable action input.
    ///
    /// The API connection webhook operation input.
    ///
    /// The API Management operation input.
    ///
    /// The HTTP action input.
    ///
    /// The manual action input.
    ///
    /// The HTTP webhook operation input.
    ///
    /// The sliding window action input.
    /// </summary>
    public partial class InputsObject
    {
        /// <summary>
        /// The body of the request.
        /// </summary>
        [JsonPropertyName("body")]
        public object Body { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("headers")]
        public Headers? Headers { get; set; }

        /// <summary>
        /// The host.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("host")]
        public Host Host { get; set; }

        /// <summary>
        /// The method of the request.
        ///
        /// The HTTP method.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("method")]
        public string Method { get; set; }

        /// <summary>
        /// The path for the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("path")]
        public string Path { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("queries")]
        public Dictionary<string, QueriesUnion> Queries { get; set; }

        /// <summary>
        /// The HTTP authentication.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("authentication")]
        public AuthenticationUnion? Authentication { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("operationOptions")]
        public string OperationOptions { get; set; }

        /// <summary>
        /// The retry policy.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("retryPolicy")]
        public RetryPolicy RetryPolicy { get; set; }

        /// <summary>
        /// The access key type.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("accessKeyType")]
        public AccessKeyType? AccessKeyType { get; set; }

        /// <summary>
        /// The schema of an API connection webhook operation.
        ///
        /// The schema of the manual action input.
        /// </summary>
        [JsonPropertyName("schema")]
        public object Schema { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("api")]
        public Reference Api { get; set; }

        [JsonPropertyName("pathTemplate")]
        public object PathTemplate { get; set; }

        /// <summary>
        /// The subscription key.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("subscriptionKey")]
        public string SubscriptionKey { get; set; }

        /// <summary>
        /// The batch group name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("batchGroupName")]
        public string BatchGroupName { get; set; }

        /// <summary>
        /// The batch configurations.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("configurations")]
        public Dictionary<string, BatchConfiguration> Configurations { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("mode")]
        public BatchActionMode? Mode { get; set; }

        /// <summary>
        /// The cookie for the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("cookie")]
        public string Cookie { get; set; }

        /// <summary>
        /// The URI of the request.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("uri")]
        public string Uri { get; set; }

        /// <summary>
        /// The operation identifier.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("operationId")]
        public string OperationId { get; set; }

        /// <summary>
        /// The operation parameters.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("parameters")]
        public Dictionary<string, object> Parameters { get; set; }

        /// <summary>
        /// The relative path.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("relativePath")]
        public string RelativePath { get; set; }

        [JsonPropertyName("subscribe")]
        public object Subscribe { get; set; }

        [JsonPropertyName("unsubscribe")]
        public object Unsubscribe { get; set; }

        /// <summary>
        /// The delay.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("delay")]
        public string Delay { get; set; }
    }

    /// <summary>
    /// The API Management API reference.
    ///
    /// The base resource reference.
    ///
    /// The function reference.
    ///
    /// The function app reference.
    /// </summary>
    public partial class Reference
    {
        /// <summary>
        /// The resource reference identifier.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The resource reference name.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The resource reference type.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public string Type { get; set; }
    }

    /// <summary>
    /// The HTTP basic authentication.
    ///
    /// The HTTP client certificate authentication.
    ///
    /// No HTTP authentication.
    ///
    /// The HTTP OAuth authentication.
    ///
    /// The HTTP raw authentication.
    /// </summary>
    public partial class AuthenticationClass
    {
        /// <summary>
        /// The password.
        ///
        /// The password used to decrypt the PFX.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("password")]
        public string Password { get; set; }

        /// <summary>
        /// The HTTP authentication type.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public AuthenticationType? Type { get; set; }

        /// <summary>
        /// The username.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("username")]
        public string Username { get; set; }

        /// <summary>
        /// The PFX.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("pfx")]
        public string Pfx { get; set; }

        /// <summary>
        /// The audience.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("audience")]
        public string Audience { get; set; }

        /// <summary>
        /// The authority.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("authority")]
        public string Authority { get; set; }

        /// <summary>
        /// The client ID.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("clientId")]
        public string ClientId { get; set; }

        /// <summary>
        /// The secret.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("secret")]
        public string Secret { get; set; }

        /// <summary>
        /// The tenant ID.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("tenant")]
        public string Tenant { get; set; }

        /// <summary>
        /// The raw authentication parameter.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("parameter")]
        public string Parameter { get; set; }

        /// <summary>
        /// The raw authentication scheme.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("scheme")]
        public string Scheme { get; set; }

        /// <summary>
        /// The raw authentication value.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("value")]
        public string Value { get; set; }
    }

    /// <summary>
    /// The batch configuration.
    /// </summary>
    public partial class BatchConfiguration
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("releaseCriteria")]
        public BatchReleaseCriteria ReleaseCriteria { get; set; }
    }

    /// <summary>
    /// The batch release criteria.
    /// </summary>
    public partial class BatchReleaseCriteria
    {
        /// <summary>
        /// The batch size in bytes.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("batchSize")]
        public long? BatchSize { get; set; }

        /// <summary>
        /// The message count.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("messageCount")]
        public long? MessageCount { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("recurrence")]
        public ReleaseCriteriaRecurrence Recurrence { get; set; }
    }

    /// <summary>
    /// The flow recurrence.
    /// </summary>
    public partial class ReleaseCriteriaRecurrence
    {
        /// <summary>
        /// The recurrence count.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("count")]
        public long? Count { get; set; }

        /// <summary>
        /// The recurrence end time.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("endTime")]
        public string EndTime { get; set; }

        /// <summary>
        /// The flow recurrence frequency.
        /// </summary>
        [JsonPropertyName("frequency")]
        public Frequency Frequency { get; set; }

        /// <summary>
        /// The recurrence interval.
        /// </summary>
        [JsonPropertyName("interval")]
        public long Interval { get; set; }

        /// <summary>
        /// The job recurrence schedule.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("schedule")]
        public PurpleSchedule Schedule { get; set; }

        /// <summary>
        /// The recurrence start time.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("startTime")]
        public string StartTime { get; set; }

        /// <summary>
        /// The recurrence time zone.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timeZone")]
        public string TimeZone { get; set; }
    }

    /// <summary>
    /// The job recurrence schedule.
    /// </summary>
    public partial class PurpleSchedule
    {
        /// <summary>
        /// The hours on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hours")]
        public StatusCode[] Hours { get; set; }

        /// <summary>
        /// The minutes on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minutes")]
        public StatusCode[] Minutes { get; set; }

        /// <summary>
        /// The days of the month on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("monthDays")]
        public long[] MonthDays { get; set; }

        /// <summary>
        /// The monthly occurence on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("monthlyOccurrences")]
        public PurpleMonthlyOccurrence[] MonthlyOccurrences { get; set; }

        /// <summary>
        /// The days of the week on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("weekDays")]
        public DayOfWeek[] WeekDays { get; set; }
    }

    /// <summary>
    /// Indicates a day of week and a count of weeks from the beginning or end of the month on
    /// which the day occurs.
    /// </summary>
    public partial class PurpleMonthlyOccurrence
    {
        /// <summary>
        /// Specifies the day of the week.
        /// </summary>
        [JsonPropertyName("dayOfWeek")]
        public DayOfWeek DayOfWeek { get; set; }

        /// <summary>
        /// Specifies the week count of this occurrence.
        /// </summary>
        [JsonPropertyName("occurrence")]
        public long Occurrence { get; set; }
    }

    /// <summary>
    /// The host.
    /// </summary>
    public partial class Host
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("api")]
        public ApiConnectionProvider Api { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("workflowReferenceName")]
        public string WorkflowReferenceName { get; set; }
    }

    /// <summary>
    /// The API connection provider.
    /// </summary>
    public partial class ApiConnectionProvider
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("runtimeUrl")]
        public Uri RuntimeUrl { get; set; }
    }

    /// <summary>
    /// The retry policy.
    /// </summary>
    public partial class RetryPolicy
    {
        /// <summary>
        /// The number of times a retry should be attempted.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("count")]
        public long? Count { get; set; }

        /// <summary>
        /// The interval between retries.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("interval")]
        public string Interval { get; set; }

        /// <summary>
        /// The maximum time delay for the exponential retry.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("maximumInterval")]
        public string MaximumInterval { get; set; }

        /// <summary>
        /// The minimum time delay for the exponential retry.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minimumInterval")]
        public string MinimumInterval { get; set; }

        /// <summary>
        /// The type of retry policy to use.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("type")]
        public RetryPolicyType? Type { get; set; }
    }

    /// <summary>
    /// The flow recurrence.
    /// </summary>
    public partial class TriggerRecurrence
    {
        /// <summary>
        /// The recurrence count.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("count")]
        public long? Count { get; set; }

        /// <summary>
        /// The recurrence end time.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("endTime")]
        public string EndTime { get; set; }

        /// <summary>
        /// The flow recurrence frequency.
        /// </summary>
        [JsonPropertyName("frequency")]
        public Frequency Frequency { get; set; }

        /// <summary>
        /// The recurrence interval.
        /// </summary>
        [JsonPropertyName("interval")]
        public long Interval { get; set; }

        /// <summary>
        /// The job recurrence schedule.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("schedule")]
        public FluffySchedule Schedule { get; set; }

        /// <summary>
        /// The recurrence start time.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("startTime")]
        public string StartTime { get; set; }

        /// <summary>
        /// The recurrence time zone.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("timeZone")]
        public string TimeZone { get; set; }
    }

    /// <summary>
    /// The job recurrence schedule.
    /// </summary>
    public partial class FluffySchedule
    {
        /// <summary>
        /// The hours on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("hours")]
        public StatusCode[] Hours { get; set; }

        /// <summary>
        /// The minutes on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("minutes")]
        public StatusCode[] Minutes { get; set; }

        /// <summary>
        /// The days of the month on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("monthDays")]
        public long[] MonthDays { get; set; }

        /// <summary>
        /// The monthly occurence on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("monthlyOccurrences")]
        public FluffyMonthlyOccurrence[] MonthlyOccurrences { get; set; }

        /// <summary>
        /// The days of the week on which this job should fire.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("weekDays")]
        public DayOfWeek[] WeekDays { get; set; }
    }

    /// <summary>
    /// Indicates a day of week and a count of weeks from the beginning or end of the month on
    /// which the day occurs.
    /// </summary>
    public partial class FluffyMonthlyOccurrence
    {
        /// <summary>
        /// Specifies the day of the week.
        /// </summary>
        [JsonPropertyName("dayOfWeek")]
        public DayOfWeek DayOfWeek { get; set; }

        /// <summary>
        /// Specifies the week count of this occurrence.
        /// </summary>
        [JsonPropertyName("occurrence")]
        public long Occurrence { get; set; }
    }

    /// <summary>
    /// The flow template operation runtime configuration.
    /// </summary>
    public partial class TriggerRuntimeConfiguration
    {
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("concurrency")]
        public FlowConcurrencyConfiguration Concurrency { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("contentTransfer")]
        public FlowContentTransferConfiguration ContentTransfer { get; set; }

        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("paginationPolicy")]
        public FlowPaginationPolicy PaginationPolicy { get; set; }
    }

    /// <summary>
    /// The trigger SplitOn configuration.
    /// </summary>
    public partial class SplitOnConfiguration
    {
        /// <summary>
        /// The correlation properties.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("correlation")]
        public SplitOnConfigurationCorrelation Correlation { get; set; }
    }

    /// <summary>
    /// The correlation properties.
    /// </summary>
    public partial class SplitOnConfigurationCorrelation
    {
        /// <summary>
        /// The client tracking identifier.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("clientTrackingId")]
        public string ClientTrackingId { get; set; }
    }

    /// <summary>
    /// The kind of the flow operation.
    /// </summary>
    public enum ActionKind //{ AddToTime, ConvertTimeZone, CurrentTime, GetFutureTime, GetPastTime, JsonToJson, JsonToText, SubtractFromTime, XmlToJson, XmlToText };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"AddToTime")]
        AddToTime = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"Alert")]
        Alert = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"ApiConnection")]
        ApiConnection = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"AzureMonitorAlert")]
        AzureMonitorAlert = 3,


        [System.Runtime.Serialization.EnumMember(Value = @"Button")]
        Button = 4,


        [System.Runtime.Serialization.EnumMember(Value = @"ConvertTimeZone")]
        ConvertTimeZone = 5,


        [System.Runtime.Serialization.EnumMember(Value = @"CurrentTime")]
        CurrentTime = 6,


        [System.Runtime.Serialization.EnumMember(Value = @"EventGrid")]
        EventGrid = 7,


        [System.Runtime.Serialization.EnumMember(Value = @"Geofence")]
        Geofence = 8,


        [System.Runtime.Serialization.EnumMember(Value = @"GetFutureTime")]
        GetFutureTime = 9,


        [System.Runtime.Serialization.EnumMember(Value = @"GetPastTime")]
        GetPastTime = 10,


        [System.Runtime.Serialization.EnumMember(Value = @"Http")]
        Http = 11,


        [System.Runtime.Serialization.EnumMember(Value = @"JsonToJson")]
        JsonToJson = 12,


        [System.Runtime.Serialization.EnumMember(Value = @"JsonToText")]
        JsonToText = 13,


        [System.Runtime.Serialization.EnumMember(Value = @"PowerApp")]
        PowerApp = 14,


        [System.Runtime.Serialization.EnumMember(Value = @"SecurityCenterAlert")]
        SecurityCenterAlert = 15,


        [System.Runtime.Serialization.EnumMember(Value = @"SubtractFromTime")]
        SubtractFromTime = 16,


        [System.Runtime.Serialization.EnumMember(Value = @"XmlToJson")]
        XmlToJson = 17,


        [System.Runtime.Serialization.EnumMember(Value = @"XmlToText")]
        XmlToText = 18,


    }

    /// <summary>
    /// The status of a flow.
    /// </summary>
    public enum FlowStatus //{ Aborted, Cancelled, Failed, Faulted, Ignored, Paused, Running, Skipped, Succeeded, Suspended, TimedOut, Waiting };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Aborted")]
        Aborted = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"Cancelled")]
        Cancelled = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"Failed")]
        Failed = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"Faulted")]
        Faulted = 3,


        [System.Runtime.Serialization.EnumMember(Value = @"Ignored")]
        Ignored = 4,


        [System.Runtime.Serialization.EnumMember(Value = @"Paused")]
        Paused = 5,


        [System.Runtime.Serialization.EnumMember(Value = @"Running")]
        Running = 6,


        [System.Runtime.Serialization.EnumMember(Value = @"Skipped")]
        Skipped = 7,


        [System.Runtime.Serialization.EnumMember(Value = @"Succeeded")]
        Succeeded = 8,


        [System.Runtime.Serialization.EnumMember(Value = @"Suspended")]
        Suspended = 9,


        [System.Runtime.Serialization.EnumMember(Value = @"TimedOut")]
        TimedOut = 10,


        [System.Runtime.Serialization.EnumMember(Value = @"Waiting")]
        Waiting = 11,


    }

    /// <summary>
    /// The flow content transfer mode.
    /// </summary>
    public enum FlowContentTransferMode// { Chunked };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Chunked")]
        Chunked = 0,


    }

    /// <summary>
    /// The type of the flow operation.
    /// </summary>
    public enum ActionType //{ ApiConnection, ApiConnectionWebhook, ApiManagement, AppendToArrayVariable, AppendToStringVariable, Compose, DecrementVariable, Expression, FlatFileDecoding, FlatFileEncoding, Foreach, Function, Http, HttpWebhook, If, IncrementVariable, InitializeVariable, IntegrationAccountArtifactLookup, Join, Liquid, ParseJson, Query, Response, Scope, Select, SendToBatch, SetVariable, Switch, Table, Terminate, Until, Wait, Workflow, XmlValidation, Xslt };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ApiConnection")]
        ApiConnection = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"ApiConnectionWebhook")]
        ApiConnectionWebhook = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"ApiManagement")]
        ApiManagement = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"AppendToArrayVariable")]
        AppendToArrayVariable = 3,


        [System.Runtime.Serialization.EnumMember(Value = @"AppendToStringVariable")]
        AppendToStringVariable = 4,


        [System.Runtime.Serialization.EnumMember(Value = @"Batch")]
        Batch = 5,


        [System.Runtime.Serialization.EnumMember(Value = @"Compose")]
        Compose = 6,


        [System.Runtime.Serialization.EnumMember(Value = @"DecrementVariable")]
        DecrementVariable = 7,


        [System.Runtime.Serialization.EnumMember(Value = @"Expression")]
        Expression = 8,


        [System.Runtime.Serialization.EnumMember(Value = @"FlatFileDecoding")]
        FlatFileDecoding = 9,


        [System.Runtime.Serialization.EnumMember(Value = @"FlatFileEncoding")]
        FlatFileEncoding = 10,


        [System.Runtime.Serialization.EnumMember(Value = @"Foreach")]
        Foreach = 11,


        [System.Runtime.Serialization.EnumMember(Value = @"Function")]
        Function = 12,


        [System.Runtime.Serialization.EnumMember(Value = @"Http")]
        Http = 13,


        [System.Runtime.Serialization.EnumMember(Value = @"HttpWebhook")]
        HttpWebhook = 14,


        [System.Runtime.Serialization.EnumMember(Value = @"If")]
        If = 15,


        [System.Runtime.Serialization.EnumMember(Value = @"IncrementVariable")]
        IncrementVariable = 16,


        [System.Runtime.Serialization.EnumMember(Value = @"InitializeVariable")]
        InitializeVariable = 17,


        [System.Runtime.Serialization.EnumMember(Value = @"IntegrationAccountArtifactLookup")]
        IntegrationAccountArtifactLookup = 18,


        [System.Runtime.Serialization.EnumMember(Value = @"Join")]
        Join = 19,


        [System.Runtime.Serialization.EnumMember(Value = @"Liquid")]
        Liquid = 20,


        [System.Runtime.Serialization.EnumMember(Value = @"ParseJson")]
        ParseJson = 21,


        [System.Runtime.Serialization.EnumMember(Value = @"Query")]
        Query = 22,


        [System.Runtime.Serialization.EnumMember(Value = @"Recurrence")]
        Recurrence = 23,


        [System.Runtime.Serialization.EnumMember(Value = @"Request")]
        Request = 24,


        [System.Runtime.Serialization.EnumMember(Value = @"Response")]
        Response = 25,


        [System.Runtime.Serialization.EnumMember(Value = @"Scope")]
        Scope = 26,


        [System.Runtime.Serialization.EnumMember(Value = @"Select")]
        Select = 27,


        [System.Runtime.Serialization.EnumMember(Value = @"SendToBatch")]
        SendToBatch = 28,


        [System.Runtime.Serialization.EnumMember(Value = @"SetVariable")]
        SetVariable = 29,


        [System.Runtime.Serialization.EnumMember(Value = @"SlidingWindow")]
        SlidingWindow = 30,


        [System.Runtime.Serialization.EnumMember(Value = @"Switch")]
        Switch = 31,


        [System.Runtime.Serialization.EnumMember(Value = @"Table")]
        Table = 32,


        [System.Runtime.Serialization.EnumMember(Value = @"Terminate")]
        Terminate = 33,


        [System.Runtime.Serialization.EnumMember(Value = @"Until")]
        Until = 34,


        [System.Runtime.Serialization.EnumMember(Value = @"Wait")]
        Wait = 35,


        [System.Runtime.Serialization.EnumMember(Value = @"Workflow")]
        Workflow = 36,


        [System.Runtime.Serialization.EnumMember(Value = @"XmlValidation")]
        XmlValidation = 37,


        [System.Runtime.Serialization.EnumMember(Value = @"Xslt")]
        Xslt = 38,

        [System.Runtime.Serialization.EnumMember(Value = @"OpenApiConnection")]
        OpenApiConnection = 39,


    }

    /// <summary>
    /// The parameter type.
    /// </summary>
    public enum OutputType //{ Array, Bool, Float, Int, Object, SecureObject, SecureString, String };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"Array")]
        Array = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"Bool")]
        Bool = 1,


        [System.Runtime.Serialization.EnumMember(Value = @"Float")]
        Float = 2,


        [System.Runtime.Serialization.EnumMember(Value = @"Int")]
        Int = 3,


        [System.Runtime.Serialization.EnumMember(Value = @"Object")]
        Object = 4,


        [System.Runtime.Serialization.EnumMember(Value = @"SecureObject")]
        SecureObject = 5,


        [System.Runtime.Serialization.EnumMember(Value = @"SecureString")]
        SecureString = 6,


        [System.Runtime.Serialization.EnumMember(Value = @"String")]
        String = 7,


    }

    /// <summary>
    /// The definition schema.
    /// </summary>
    public enum WorkflowDefinitionSchema //{ HttpsSchemaManagementAzureComProvidersMicrosoftLogicSchemas20160601WorkflowdefinitionJson };
    {

        [System.Runtime.Serialization.EnumMember(Value = @"https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#")]
        Https__schema_management_azure_com_providers_Microsoft_Logic_schemas_20160601_workflowdefinition_json_ = 0,


    }

    /// <summary>
    /// The access key type.
    /// </summary>
    public enum AccessKeyType //{ Primary, Secondary };
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Primary")]
        Primary = 0,


        [System.Runtime.Serialization.EnumMember(Value = @"Secondary")]
        Secondary = 1,
    }

    /// <summary>
    /// The HTTP authentication type.
    /// </summary>
    public enum AuthenticationType //{ ActiveDirectoryOAuth, Basic, ClientCertificate, None, Raw };
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ActiveDirectoryOAuth")] 
        ActiveDirectoryOAuth,

        [System.Runtime.Serialization.EnumMember(Value = @"Basic")] 
        Basic,

        [System.Runtime.Serialization.EnumMember(Value = @"ClientCertificate")] 
        ClientCertificate,

        [System.Runtime.Serialization.EnumMember(Value = @"None")] 
        None,

        [System.Runtime.Serialization.EnumMember(Value = @"Raw")] 
        Raw 
    };

    /// <summary>
    /// The flow recurrence frequency.
    /// </summary>
    public enum Frequency 
    { 
        [System.Runtime.Serialization.EnumMember(Value = @"Day")] 
        Day,

        [System.Runtime.Serialization.EnumMember(Value = @"Hour")] 
        Hour,

        [System.Runtime.Serialization.EnumMember(Value = @"Minute")] 
        Minute,

        [System.Runtime.Serialization.EnumMember(Value = @"Month")] 
        Month,

        [System.Runtime.Serialization.EnumMember(Value = @"Second")] 
        Second, 
        
        [System.Runtime.Serialization.EnumMember(Value = @"Week")] 
        Week,

        [System.Runtime.Serialization.EnumMember(Value = @"Year")] 
        Year
    };

    /// <summary>
    /// Specifies the day of the week.
    /// </summary>
    public enum DayOfWeek 
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Friday")] 
        Friday,

        [System.Runtime.Serialization.EnumMember(Value = @"Monday")] 
        Monday,

        [System.Runtime.Serialization.EnumMember(Value = @"Saturday")] 
        Saturday,

        [System.Runtime.Serialization.EnumMember(Value = @"Sunday")] 
        Sunday,

        [System.Runtime.Serialization.EnumMember(Value = @"Thursday")] 
        Thursday,

        [System.Runtime.Serialization.EnumMember(Value = @"Tuesday")] 
        Tuesday,

        [System.Runtime.Serialization.EnumMember(Value = @"Wednesday")] 
        Wednesday 
    };

    /// <summary>
    /// The batch action mode.
    /// </summary>
    public enum BatchActionMode 
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Inline")] 
        Inline,

        [System.Runtime.Serialization.EnumMember(Value = @"IntegrationAccount")] 
        IntegrationAccount
    };

    /// <summary>
    /// The type of retry policy to use.
    /// </summary>
    public enum RetryPolicyType 
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Exponential")] 
        Exponential,

        [System.Runtime.Serialization.EnumMember(Value = @"Fixed")] 
        Fixed,

        [System.Runtime.Serialization.EnumMember(Value = @"None")] 
        None
    };

    /// <summary>
    /// The kind of the flow operation.
    /// </summary>
    public enum TriggerKind 
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Alert")] 
        Alert,

        [System.Runtime.Serialization.EnumMember(Value = @"AzureMonitorAlert")] 
        AzureMonitorAlert,

        [System.Runtime.Serialization.EnumMember(Value = @"Button")] 
        Button,

        [System.Runtime.Serialization.EnumMember(Value = @"EventGrid")] 
        EventGrid,

        [System.Runtime.Serialization.EnumMember(Value = @"Geofence")] 
        Geofence,

        [System.Runtime.Serialization.EnumMember(Value = @"Http")] 
        Http,

        [System.Runtime.Serialization.EnumMember(Value = @"PowerApp")] 
        PowerApp,

        [System.Runtime.Serialization.EnumMember(Value = @"SecurityCenterAlert")] 
        SecurityCenterAlert,

        [System.Runtime.Serialization.EnumMember(Value = @"PowerAppV2")]
        PowerAppV2
    };

    /// <summary>
    /// The type of the flow operation.
    /// </summary>
    public enum TriggerType 
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ApiConnection")] 
        ApiConnection,

        [System.Runtime.Serialization.EnumMember(Value = @"ApiConnectionWebhook")] 
        ApiConnectionWebhook,

        [System.Runtime.Serialization.EnumMember(Value = @"ApiManagement")] 
        ApiManagement,

        [System.Runtime.Serialization.EnumMember(Value = @"Batch")] 
        Batch,

        [System.Runtime.Serialization.EnumMember(Value = @"Http")] 
        Http,

        [System.Runtime.Serialization.EnumMember(Value = @"HttpWebhook")] 
        HttpWebhook,

        [System.Runtime.Serialization.EnumMember(Value = @"Recurrence")] 
        Recurrence,

        [System.Runtime.Serialization.EnumMember(Value = @"Request")] 
        Request,

        [System.Runtime.Serialization.EnumMember(Value = @"SlidingWindow")] 
        SlidingWindow,

        [System.Runtime.Serialization.EnumMember(Value = @"OpenApiConnectionWebhook")]
        OpenApiConnectionWebhook
    };

    public partial struct InputsUnion
    {
        public InputsObject Object;
        public string String;

        public static implicit operator InputsUnion(InputsObject Object) => new InputsUnion { Object = Object };
        public static implicit operator InputsUnion(string String) => new InputsUnion { String = String };
    }

    /// <summary>
    /// The source.
    ///
    /// The For Each expression.
    ///
    /// The select source.
    /// </summary>
    public partial struct From
    {
        public object[] AnythingArray;
        public string String;

        public static implicit operator From(object[] AnythingArray) => new From { AnythingArray = AnythingArray };
        public static implicit operator From(string String) => new From { String = String };
    }

    /// <summary>
    /// The Switch expression.
    ///
    /// The until count limit.
    ///
    /// The code.
    /// </summary>
    public partial struct Expression
    {
        public double? Double;
        public string String;
        public ExpressionClass ExpressionClass;

        public static implicit operator Expression(double Double) => new Expression { Double = Double };
        public static implicit operator Expression(string String) => new Expression { String = String };
        public static implicit operator Expression(ExpressionClass ExpressionClass) => new Expression { ExpressionClass = ExpressionClass };
    }

    public partial class ExpressionClass 
    {
        /// <summary>
        /// The flow run actions.
        /// </summary>
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        [JsonPropertyName("actions")]
        public Dictionary<string, Action> Actions { get; set; }
    }

    /// <summary>
    /// The HTTP authentication.
    /// </summary>
    public partial struct AuthenticationUnion
    {
        public AuthenticationClass AuthenticationClass;
        public string String;

        public static implicit operator AuthenticationUnion(AuthenticationClass AuthenticationClass) => new AuthenticationUnion { AuthenticationClass = AuthenticationClass };
        public static implicit operator AuthenticationUnion(string String) => new AuthenticationUnion { String = String };
    }

    /// <summary>
    /// The status code for the response.
    /// </summary>
    public partial struct StatusCode
    {
        public long? Integer;
        public string String;

        public static implicit operator StatusCode(long Integer) => new StatusCode { Integer = Integer };
        public static implicit operator StatusCode(string String) => new StatusCode { String = String };
    }

    public partial struct QueriesUnion
    {
        public bool? Bool;
        public double? Double;
        public long? Integer;
        public string String;

        public static implicit operator QueriesUnion(bool Bool) => new QueriesUnion { Bool = Bool };
        public static implicit operator QueriesUnion(double Double) => new QueriesUnion { Double = Double };
        public static implicit operator QueriesUnion(long Integer) => new QueriesUnion { Integer = Integer };
        public static implicit operator QueriesUnion(string String) => new QueriesUnion { String = String };
        public bool IsNull => Bool == null && Double == null && Integer == null && String == null;
    }

    /// <summary>
    /// The headers for the request.
    /// </summary>
    public partial struct Headers
    {
        public Dictionary<string, QueriesUnion> AnythingMap;
        public string String;

        public static implicit operator Headers(Dictionary<string, QueriesUnion> AnythingMap) => new Headers { AnythingMap = AnythingMap };
        public static implicit operator Headers(string String) => new Headers { String = String };
    }

    public partial class WorkflowDefinition
    {
        public static WorkflowDefinition FromJson(string json) => JsonSerializer.Deserialize<WorkflowDefinition>(json, WorkflowConverter.Settings);
    }

    public static class WorkflowSerialize
    {
        public static string ToJson(this WorkflowDefinition self) => JsonSerializer.Serialize(self, WorkflowConverter.Settings);
    }

    internal static class WorkflowConverter
    {
        public static readonly JsonSerializerOptions Settings = new JsonSerializerOptions(JsonSerializerDefaults.General)
        {
            Converters =
            {
                SchemaConverter.Singleton,
                InputsUnionConverter.Singleton,
                FromConverter.Singleton,
                ActionKindConverter.Singleton,
                ExpressionConverter.Singleton,
                RunAfterConverter.Singleton,
                FlowContentTransferModeConverter.Singleton,
                ActionTypeConverter.Singleton,
                OutputTypeConverter.Singleton,
                AccessKeyTypeConverter.Singleton,
                AuthenticationUnionConverter.Singleton,
                AuthenticationTypeConverter.Singleton,
                FrequencyConverter.Singleton,
                StatusCodeConverter.Singleton,
                DayOfWeekConverter.Singleton,
                HeadersConverter.Singleton,
                QueriesUnionConverter.Singleton,
                BatchActionModeConverter.Singleton,
                RetryPolicyTypeConverter.Singleton,
                TriggerKindConverter.Singleton,
                TriggerTypeConverter.Singleton,
                new DateOnlyConverter(),
                new TimeOnlyConverter(),
                IsoDateTimeOffsetConverter.Singleton
            },
        };
    }

    internal class SchemaConverter : EnumConverter<WorkflowDefinitionSchema>
    {
        public static readonly SchemaConverter Singleton = new SchemaConverter();
    }

    internal class InputsUnionConverter : JsonConverter<InputsUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(InputsUnion);

        public override InputsUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new InputsUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<InputsObject>(ref reader, options);
                    return new InputsUnion { Object = objectValue };
            }
            throw new Exception("Cannot unmarshal type InputsUnion");
        }

        public override void Write(Utf8JsonWriter writer, InputsUnion value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.Object != null)
            {
                JsonSerializer.Serialize(writer, value.Object, options);
                return;
            }
            throw new Exception("Cannot marshal type InputsUnion");
        }

        public static readonly InputsUnionConverter Singleton = new InputsUnionConverter();
    }

    internal class FromConverter : JsonConverter<From>
    {
        public override bool CanConvert(Type t) => t == typeof(From);

        public override From Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new From { String = stringValue };
                case JsonTokenType.StartArray:
                    var arrayValue = JsonSerializer.Deserialize<object[]>(ref reader, options);
                    return new From { AnythingArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type From");
        }

        public override void Write(Utf8JsonWriter writer, From value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingArray != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingArray, options);
                return;
            }
            throw new Exception("Cannot marshal type From");
        }

        public static readonly FromConverter Singleton = new FromConverter();
    }

    internal class ActionKindConverter : EnumConverter<ActionKind>
    {
        public static readonly ActionKindConverter Singleton = new ActionKindConverter();
    }

    internal class ExpressionConverter : JsonConverter<Expression>
    {
        public override bool CanConvert(Type t) => t == typeof(Expression);

        public override Expression Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Number:
                    var doubleValue = reader.GetDouble();
                    return new Expression { Double = doubleValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Expression { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<ExpressionClass>(ref reader, options);
                    return new Expression { ExpressionClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type Expression");
        }

        public override void Write(Utf8JsonWriter writer, Expression value, JsonSerializerOptions options)
        {
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.ExpressionClass != null)
            {
                JsonSerializer.Serialize(writer, value.ExpressionClass, options);
                return;
            }
            throw new Exception("Cannot marshal type Expression");
        }

        public static readonly ExpressionConverter Singleton = new ExpressionConverter();
    }

    internal class RunAfterConverter : EnumConverter<FlowStatus>
    {
        public static readonly RunAfterConverter Singleton = new RunAfterConverter();
    }

    internal class FlowContentTransferModeConverter : EnumConverter<FlowContentTransferMode>
    {
        public static readonly FlowContentTransferModeConverter Singleton = new FlowContentTransferModeConverter();
    }

    internal class ActionTypeConverter : EnumConverter<ActionType>
    {
        public static readonly ActionTypeConverter Singleton = new ActionTypeConverter();
    }

    internal class OutputTypeConverter : EnumConverter<OutputType>
    {
        public static readonly OutputTypeConverter Singleton = new OutputTypeConverter();
    }

    internal class AccessKeyTypeConverter : EnumConverter<AccessKeyType>
    {
        public static readonly AccessKeyTypeConverter Singleton = new AccessKeyTypeConverter();
    }

    internal class AuthenticationUnionConverter : JsonConverter<AuthenticationUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(AuthenticationUnion);

        public override AuthenticationUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new AuthenticationUnion { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<AuthenticationClass>(ref reader, options);
                    return new AuthenticationUnion { AuthenticationClass = objectValue };
            }
            throw new Exception("Cannot unmarshal type AuthenticationUnion");
        }

        public override void Write(Utf8JsonWriter writer, AuthenticationUnion value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AuthenticationClass != null)
            {
                JsonSerializer.Serialize(writer, value.AuthenticationClass, options);
                return;
            }
            throw new Exception("Cannot marshal type AuthenticationUnion");
        }

        public static readonly AuthenticationUnionConverter Singleton = new AuthenticationUnionConverter();
    }

    internal class AuthenticationTypeConverter : EnumConverter<AuthenticationType>
    {
        public static readonly AuthenticationTypeConverter Singleton = new AuthenticationTypeConverter();
    }

    internal class FrequencyConverter : EnumConverter<Frequency>
    {
        public static readonly FrequencyConverter Singleton = new FrequencyConverter();
    }

    internal class StatusCodeConverter : JsonConverter<StatusCode>
    {
        public override bool CanConvert(Type t) => t == typeof(StatusCode);

        public override StatusCode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Number:
                    var integerValue = reader.GetInt64();
                    return new StatusCode { Integer = integerValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new StatusCode { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type StatusCode");
        }

        public override void Write(Utf8JsonWriter writer, StatusCode value, JsonSerializerOptions options)
        {
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            throw new Exception("Cannot marshal type StatusCode");
        }

        public static readonly StatusCodeConverter Singleton = new StatusCodeConverter();
    }

    internal class DayOfWeekConverter : EnumConverter<DayOfWeek>
    {
        public static readonly DayOfWeekConverter Singleton = new DayOfWeekConverter();
    }

    internal class HeadersConverter : JsonConverter<Headers>
    {
        public override bool CanConvert(Type t) => t == typeof(Headers);

        public override Headers Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new Headers { String = stringValue };
                case JsonTokenType.StartObject:
                    var objectValue = JsonSerializer.Deserialize<Dictionary<string, QueriesUnion>>(ref reader, options);
                    return new Headers { AnythingMap = objectValue };
            }
            throw new Exception("Cannot unmarshal type Headers");
        }

        public override void Write(Utf8JsonWriter writer, Headers value, JsonSerializerOptions options)
        {
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            if (value.AnythingMap != null)
            {
                JsonSerializer.Serialize(writer, value.AnythingMap, options);
                return;
            }
            throw new Exception("Cannot marshal type Headers");
        }

        public static readonly HeadersConverter Singleton = new HeadersConverter();
    }

    internal class QueriesUnionConverter : JsonConverter<QueriesUnion>
    {
        public override bool CanConvert(Type t) => t == typeof(QueriesUnion);

        public override QueriesUnion Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.Null:
                    return new QueriesUnion { };
                case JsonTokenType.Number:
                    try
                    {
                        var integerValue = reader.GetInt64();
                        return new QueriesUnion { Integer = integerValue };
                    }
                    catch (Exception ex) when (ex is FormatException || ex is InvalidOperationException)
                    {
                        var doubleValue = reader.GetDouble();
                        return new QueriesUnion { Double = doubleValue };
                    }
                case JsonTokenType.True:
                case JsonTokenType.False:
                    var boolValue = reader.GetBoolean();
                    return new QueriesUnion { Bool = boolValue };
                case JsonTokenType.String:
                    var stringValue = reader.GetString();
                    return new QueriesUnion { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type QueriesUnion");
        }

        public override void Write(Utf8JsonWriter writer, QueriesUnion value, JsonSerializerOptions options)
        {
            if (value.IsNull)
            {
                writer.WriteNullValue();
                return;
            }
            if (value.Integer != null)
            {
                JsonSerializer.Serialize(writer, value.Integer.Value, options);
                return;
            }
            if (value.Double != null)
            {
                JsonSerializer.Serialize(writer, value.Double.Value, options);
                return;
            }
            if (value.Bool != null)
            {
                JsonSerializer.Serialize(writer, value.Bool.Value, options);
                return;
            }
            if (value.String != null)
            {
                JsonSerializer.Serialize(writer, value.String, options);
                return;
            }
            throw new Exception("Cannot marshal type QueriesUnion");
        }

        public static readonly QueriesUnionConverter Singleton = new QueriesUnionConverter();
    }

    internal class BatchActionModeConverter : EnumConverter<BatchActionMode>
    {
        public static readonly BatchActionModeConverter Singleton = new BatchActionModeConverter();
    }

    internal class RetryPolicyTypeConverter : EnumConverter<RetryPolicyType>
    {
        public static readonly RetryPolicyTypeConverter Singleton = new RetryPolicyTypeConverter();
    }

    internal class TriggerKindConverter : EnumConverter<TriggerKind>
    {
        public static readonly TriggerKindConverter Singleton = new TriggerKindConverter();
    }

    internal class TriggerTypeConverter : EnumConverter<TriggerType>
    {
        public static readonly TriggerTypeConverter Singleton = new TriggerTypeConverter();
    }

    public class DateOnlyConverter : JsonConverter<DateTime>
    {
        private readonly string serializationFormat;
        public DateOnlyConverter() : this(null) { }

        public DateOnlyConverter(string serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
        }

        public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateTime.Parse(value).Date;
        }

        public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.Date.ToString(serializationFormat));
    }

    public class TimeOnlyConverter : JsonConverter<TimeSpan>
    {
        private readonly string serializationFormat;

        public TimeOnlyConverter() : this(null) { }

        public TimeOnlyConverter(string serializationFormat)
        {
            this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
        }

        public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            return DateTime.Parse(value).TimeOfDay;
        }

        public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
            => writer.WriteStringValue(value.ToString(serializationFormat));
    }

    internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
    {
        public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

        private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

        private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
        private string _dateTimeFormat;
        private CultureInfo _culture;

        public DateTimeStyles DateTimeStyles
        {
            get => _dateTimeStyles;
            set => _dateTimeStyles = value;
        }

        public string DateTimeFormat
        {
            get => _dateTimeFormat ?? string.Empty;
            set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
        }

        public CultureInfo Culture
        {
            get => _culture ?? CultureInfo.CurrentCulture;
            set => _culture = value;
        }

        public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
        {
            string text;


            if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
                || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
            {
                value = value.ToUniversalTime();
            }

            text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

            writer.WriteStringValue(text);
        }

        public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            string dateText = reader.GetString();

            if (string.IsNullOrEmpty(dateText) == false)
            {
                if (!string.IsNullOrEmpty(_dateTimeFormat))
                {
                    return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
                }
                else
                {
                    return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
                }
            }
            else
            {
                return default(DateTimeOffset);
            }
        }


        public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
    }

    internal class EnumConverter<TEnum> : JsonConverter<TEnum> where TEnum : Enum
    {
        public override bool CanConvert(Type t) => t == typeof(TEnum);

        public override TEnum Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var value = reader.GetString();
            try
            {
                var enumValue = AttributesHelpers.ToEnum<TEnum>(value);
                return enumValue;
            }
            catch (Exception ex)
            {
                throw new Exception("Cannot unmarshal type " + typeof(TEnum).Name);
            }
        }

        public override void Write(Utf8JsonWriter writer, TEnum value, JsonSerializerOptions options)
        {
            try
            {
                var valueString = AttributesHelpers.ToEnumString<TEnum>(value);
                JsonSerializer.Serialize(writer, valueString, options);
            }
            catch (Exception ex)
            {
                throw new Exception("Cannot marshal type " + typeof(TEnum).Name);
            }
        }

        public static readonly ActionTypeConverter Singleton = new ActionTypeConverter();
    }
}
#pragma warning restore CS8618
#pragma warning restore CS8601
#pragma warning restore CS8603
